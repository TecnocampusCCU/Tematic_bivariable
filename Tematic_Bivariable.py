# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Tematic_Bivariable
                                 A QGIS plugin
 Tematic_Bivariable
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-01-26
        git sha              : $Format:%H$
        copyright            : (C) 2021 by CCU
        email                : jlopez@tecnocampus.cat
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Tematic_Bivariable_dialog import Tematic_BivariableDialog
import os.path

import processing
import sys
import os

from os.path import expanduser
from PyQt5 import QtCore
from PyQt5.QtCore import *
from PyQt5.QtGui import *
#from PyQt5.QtGui import QPainter, QColor, QPen
#from PyQt5.QtWidgets import (QApplication, QComboBox, QDialog,QDialogButtonBox, QFormLayout, QGridLayout, QGroupBox, QHBoxLayout,QLabel, QLineEdit, QMenu, QMenuBar, QPushButton, QSpinBox, QTextEdit,QVBoxLayout)
from PyQt5.QtWidgets import QAction,QMessageBox,QTableWidgetItem,QApplication,QSizePolicy,QFormLayout,QGridLayout,QDialogButtonBox,QFileDialog,QDockWidget,QProgressBar,QInputDialog,QLineEdit,QColorDialog,QToolBar,QWidget,QGraphicsScene
from qgis.core import QgsMapLayer,QgsWkbTypes
from qgis.core import QgsDataSourceUri
from qgis.core import QgsVectorLayer
from qgis.core import QgsField
from qgis.core import QgsVectorFileWriter
from qgis.core import QgsGraduatedSymbolRenderer
from qgis.core import QgsCategorizedSymbolRenderer
from qgis.core import QgsRuleBasedRenderer
from qgis.core import QgsGradientColorRamp
from qgis.core import QgsProject
from qgis.core import QgsRendererRange
from qgis.core import QgsSymbol
from qgis.core import QgsFillSymbol
from qgis.core import QgsLineSymbol
from qgis.core import QgsSymbolLayerRegistry
from qgis.core import QgsRandomColorRamp
from qgis.core import QgsRendererRangeLabelFormat
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsPalLayerSettings
from qgis.core import QgsTextFormat
from qgis.core import QgsTextBufferSettings
from qgis.core import QgsVectorLayerSimpleLabeling
from qgis.core import QgsProcessingFeedback, Qgis
from qgis.core import QgsWkbTypes,QgsCoordinateReferenceSystem,QgsCoordinateTransform
from qgis.core import QgsVectorLayerExporter,QgsMapLayerProxyModel, QgsRenderContext
from string import ascii_letters, digits

from qgis.gui import QgsMessageBar,QgsTabWidget,QgsBlendModeComboBox



import psycopg2
import unicodedata
import datetime
import time
from qgis.utils import iface
from PyQt5.QtSql import *
import qgis.utils
import collections
from math import sqrt
from macpath import curdir
import csv

entitat_poi=""
Fitxer=""
Path_Inicial=expanduser("~")
progress=None
Versio_modul="V_Q3.210223"
geometria=""
QEstudis=None
Detall_MEM=""
index_top=['A','B','C','D','E','F','G','H','I','J']
index_bottom=['1','2','3','4','5','6','7','8','9','10']
blend_mode_combo_box=None
blend_mode=None
blend_mode_combo_box=None
renderContext = QgsRenderContext()
max_rangs=5
img_Paletes=[]
Paletes_RGB=[]
Camp_V1=""
Camp_V2=""
Vista_Previa=False
TOP_Layer=""
BOTTOM_Layer=""


class Tematic_Bivariable:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Tematic_Bivariable_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)
        self.dlg = Tematic_BivariableDialog()
        self.dlg.btoSortir.clicked.connect(self.on_click_Sortir)
        self.dlg.Tematic_Top.currentIndexChanged.connect(self.on_Change_ComboTOP)
        self.dlg.Tematic_Bottom.currentIndexChanged.connect(self.on_Change_ComboBOTTOM)
        self.dlg.TOP_Reload.clicked.connect(self.Recarga_Llegenda_TOP)
        self.dlg.BOTTOM_Reload.clicked.connect(self.Recarga_Llegenda_BOTTOM)
        self.dlg.btoInici.clicked.connect(self.on_click_Inici)
        self.dlg.combo.currentIndexChanged.connect(self.on_Change_combo_Paleta)
        self.dlg.VistaPrevia.clicked.connect(self.on_click_VistaPrevia)
        self.dlg.PaletaLayers.toggled.connect(self.on_toggled_Paleta)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&CCU')
        
        trobat=False
        for x in iface.mainWindow().findChildren(QToolBar,'CCU'): 
            self.toolbar = x
            trobat=True
        
        if not trobat:
            self.toolbar = self.iface.addToolBar('CCU')
            self.toolbar.setObjectName('CCU')
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Tematic_Bivariable', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def add_blend_mode_combobox(self):
        """Add blend mode combobox."""
        self.blend_mode_combo_box = QgsBlendModeComboBox(self.dlg)
        # Default value
        self.blend_mode = QPainter.CompositionMode_Multiply
        self.blend_mode_combo_box.setBlendMode(self.blend_mode)
        blend_mode_combo_box = self.blend_mode_combo_box

        # Signal inherited from QComboBox
        blend_mode_combo_box.currentIndexChanged.connect(
            self.assign_blend_mode
        )
        blend_mode_combo_box.setFixedSize(130,22)
        blend_mode_combo_box.move(210,146)

    def assign_blend_mode(self, index):
        """Assign blend mode."""
        # See enum QPainter.CompositionMode for correspondance
        enum_composition_mode = [
            'CompositionMode_SourceOver',
            'CompositionMode_DestinationOver',
            'CompositionMode_Clear',
            'CompositionMode_Source',
            'CompositionMode_Destination',
            'CompositionMode_SourceIn',
            'CompositionMode_DestinationIn',
            'CompositionMode_SourceOut',
            'CompositionMode_DestinationOut',
            'CompositionMode_SourceAtop',
            'CompositionMode_DestinationAtop',
            'CompositionMode_Xor',
            'CompositionMode_Plus',
            'CompositionMode_Multiply',
            'CompositionMode_Screen',
            'CompositionMode_Overlay',
            'CompositionMode_Darken',
            'CompositionMode_Lighten',
            'CompositionMode_ColorDodge',
            'CompositionMode_ColorBurn',
            'CompositionMode_HardLight',
            'CompositionMode_SoftLight',
            'CompositionMode_Difference',
            'CompositionMode_Exclusion',
            'RasterOp_SourceOrDestination',
            'RasterOp_SourceAndDestination',
            'RasterOp_SourceXorDestination',
            'RasterOp_NotSourceAndNotDestination',
            'RasterOp_NotSourceOrNotDestination',
            'RasterOp_NotSourceXorDestination',
            'RasterOp_NotSource',
            'RasterOp_NotSourceAndDestination',
            'RasterOp_SourceAndNotDestination'
        ]
        self.blend_mode = getattr(
            QPainter,
            enum_composition_mode[self.blend_mode_combo_box.blendMode()]
        )
        # fix_print_with_import
        #print(enum_composition_mode[self.blend_mode_combo_box.blendMode()])

    def on_click_Sortir(self):
        '''
        Tanca la finestra del plugin 
        '''
        self.EstatInicial()
        self.dlg.close()

    def EstatInicial(self):
        '''
        @param self:
        Resteja tots els valors per defecte del plugin: estat inicial.
        '''
        global micolor
        global micolorTag
        global Versio_modul
        global QEstudis
        self.dlg.progressBar.setValue(0)
        self.dlg.progressBar.setVisible(False)
        self.dlg.progressBar.setMaximum(100)
        self.dlg.versio.setText(Versio_modul)
        self.Recarga_Llegenda_TOP()
        self.Recarga_Llegenda_BOTTOM()

        # Add blend combobox and listen to event
        if not hasattr(self, 'blend_mode_combo_box'):
            self.add_blend_mode_combobox()
        self.Carrega_Paletes()
        self.dlg.PaletaLayers.setChecked(True)

    def Carrega_Paletes(self):
        global img_Paletes
        global Paletes_RGB
        #                                                                         0                    1                    2
        # Paletes_RGB[x]        :   Paleta nºx                          ( [ [A1],[A2],[A3] ] , [ [B1],[B2],[B3] ] , [ [C1],[C2],[C3] ] )
        
        #                                                                   0    1    2
        # Paletes_RGB[x][y]     :   Paleta nºx || columna y             ( [A1],[A2],[A3] )
        
        #                                                                   0
        # Paletes_RGB[x][y][z]  :   Paleta nºx || columna y || color    (  A1  )

        # Numero de filas de la paleta: len(Paletes_RGB[x][y])
        # Numero de columnes de la paleta: len(Paletes_RGB[x])

        #       [ [[A1],[A2],[A3]] , [[B1],[B2],[B3]] , [[C1],[C2],[C3]] ],

        #       [ [[A1],[A2],[A3],[A4]] , [[B1],[B2],[B3],[B4]] , [[C1],[C2],[C3],[C4]]  , [[D1],[D2],[D3],[D4]] ],
        
        Paletes_RGB=[
            [[[255, 255, 190],[170, 215, 232],[42, 120, 182]],[[235, 140, 108],[163, 120, 130],[90, 100, 145]],[[205, 0, 35],[172, 48, 61],[128, 75, 105]]],
            [[[255, 255, 190],[141, 200, 129],[23, 151, 64]],[[235, 139, 110],[150, 130, 80],[77, 120, 56]],[[217, 24, 32],[166, 56, 37],[116, 87, 45]]],
            [[[255, 255, 255],[253, 184, 96],[230, 95, 3]],[[177, 171, 210],[183, 120, 120],[191, 86, 38]],[[97, 60, 148],[127, 70, 113],[156, 81, 77]]],
            [[[235, 12, 129],[244, 150, 164],[240, 118, 33]],[[203, 154, 199],[232, 232, 232],[205, 225, 140]],[[91, 80, 159],[155, 200, 213],[13, 136, 69]]],
            [[[255, 250, 245],[228, 211, 230],[187, 139, 189]],[[250, 248, 189],[249, 191, 187],[240, 94, 143]],[[245, 236, 33],[245, 128, 33],[232, 33, 40]]],
            [[[232, 232, 232],[255, 172, 169],[198, 90, 88]],[[179, 213, 223],[171, 158, 167],[150, 85, 85]],[[105, 171, 195],[100, 128, 142],[85, 66, 72]]],
            [[[232, 232, 232],[176, 227, 227],[97, 201, 199]],[[221, 176, 219],[165, 172, 216],[89, 151, 188]],[[187, 99, 177],[138, 97, 176],[60, 71, 153]]],
            [[[232, 232, 232],[228, 219, 164],[198, 180, 72]],[[200, 184, 218],[200, 173, 158],[173, 143, 73]],[[152, 113, 180],[150, 106, 129],[124, 79, 50]]],
            [[[255, 255, 255],[187, 187, 187],[100, 100, 100]],[[226, 123, 144],[170, 100, 110],[125, 75, 86]],[[205, 0, 35],[175, 25, 50],[155, 50, 70]]],
            [[[243, 243, 243],[194, 240, 206],[138, 225, 174]],[[234, 197, 221],[158, 197, 211],[126, 197, 177]],[[230, 162, 208],[187, 159, 206],[122, 142, 174]]],
            [[[217, 232, 255],[216, 166, 255],[191, 100, 255]],[[202, 202, 255],[143, 127, 255],[125, 100, 255]],[[100, 194, 255],[90, 115, 255],[30, 30, 255]]],
            [[[232, 232, 232],[181, 190, 222],[108, 131, 185]],[[186, 214, 190],[147, 178, 180],[87, 120, 151]],[[121, 173, 124],[95, 145, 117],[46, 90, 91]]],
            [[[23, 23, 23],[27, 36, 91],[57, 75, 183]],[[55, 71, 37],[55, 82, 97],[82, 112, 182]],[[103, 142, 75],[105, 149, 126],[131, 176, 205]]],
            [[[0, 0, 0],[68, 68, 68],[155, 155, 155]],[[132, 29, 50],[155, 85, 95],[180, 130, 141]],[[255, 50, 85],[230, 80, 105],[205, 100, 120]]],
            [[[255, 240, 217],[205, 255, 166],[164, 255, 100]],[[255, 218, 165],[239, 255, 127],[231, 255, 100]],[[255, 161, 100],[255, 230, 90],[255, 255, 30]]],
            [[[178, 179, 0],[166, 141, 0],[161, 63, 2]],[[126, 156, 0],[113, 128, 0],[90, 52, 0]],[[64, 154, 0],[39, 89, 0],[38, 38, 0]]],
            [[[23, 23, 23],[91, 82, 27],[183, 165, 57]],[[53, 37, 71],[97, 70, 55],[182, 152, 82]],[[114, 75, 142],[149, 105, 128],[205, 160, 131]]],
            [[[0, 0, 0],[0, 25, 0],[2, 65, 0],[0, 127, 0]],[[25, 0, 0],[38, 38, 0],[39, 89, 0],[64, 154, 0]],[[63, 0, 0],[90, 52, 0],[113, 128, 0],[126, 156, 0]],[[140, 0, 0],[161, 63, 2],[166, 141, 0],[178, 179, 0]]],
            [[[255, 255, 255],[255, 230, 255],[253, 192, 252],[255, 128, 255]],[[231, 255, 255],[217, 217, 255],[216, 166, 255],[191, 100, 255]],[[192, 253, 255],[166, 203, 255],[142, 126, 250],[129, 100, 254]],[[114, 255, 255],[102, 191, 248],[90, 115, 252],[75, 75, 255]]],
            [[[255, 255, 215],[250, 240, 168],[244, 255, 85],[240, 210, 0]],[[255, 236, 198],[248, 206, 168],[237, 157, 86],[230, 110, 0]],[[255, 198, 199],[232, 168, 169],[205, 85, 85],[180, 0, 0]],[[232, 198, 215],[202, 168, 185],[153, 83, 119],[100, 0, 50]]],
            [[[255, 255, 255],[230, 255, 230],[192, 255, 191],[125, 255, 125]],[[255, 231, 231],[255, 240, 217],[205, 255, 166],[164, 255, 100]],[[255, 193, 192],[255, 218, 165],[239, 255, 127],[231, 255, 100]],[[255, 117, 116],[255, 161, 100],[255, 230, 90],[255, 255, 30]]]
        ]

        self.dlg.combo.setStyleSheet("{line-height: 400px; color: black; background-color: lightgray}")
        self.dlg.combo.addItem("Selecciona Paleta")
        for index,paleta in enumerate(Paletes_RGB):
            self.dlg.combo.addItem(str(index+1))
            colors=Paletes_RGB[index]
            img1=self.generate_image_matrix(colors,len(colors),len(colors[0]),20,False)
            img_Paletes.append(img1)
            self.dlg.combo.setItemData(index+1,img1,1)


    def generate_image_matrix(self,
            colors,
            width,
            height,
            square_size,
            reverse=False):
        """
        Generate intermediate legend image for one layer.

        The input are a list of QColor, the height, the width
        and reverse for color ordering (x or y)
        """
        origin_x = 0
        origin_y = 0
        w, h = width * square_size, height * square_size
        img = QImage(w + 1, h + 1, QImage.Format_RGB32)
        # TODO: Manage border when pen color
        # img = QImage(w + 1, h + 1, QImage.Format_ARGB32)

        qp = QPainter()
        qp.begin(img)
        #for index1, val1 in enumerate(colors):
        #print("colors")
        #print("filas:"+str(height)+" columnas:"+str(width))
        for index_y in (range(height)):
            for index_x in range(width):
                #print(colors[index_x][index_y][0])
                qp.setBrush(QColor(colors[index_y][index_x][0],colors[index_y][index_x][1],colors[index_y][index_x][2]))
                qp.setPen(Qt.NoPen)

                qp.drawRect(
                    origin_x + index_x * square_size,
                    (origin_y + index_y * square_size),
                    origin_x + (index_x + 1) * square_size,
                    (origin_y + (index_y + 1) * square_size)
                )
        qp.end()

        return img.mirrored(False,True)

    def on_toggled_Paleta(self):
        if self.dlg.PaletaLayers.isChecked():
            self.dlg.combo.setVisible(False)
            self.dlg.Reverse_Top.setVisible(True)
            self.dlg.Reverse_Bottom.setVisible(True)
            self.dlg.Rotate_axis.setVisible(True)
            self.dlg.VistaPrevia.setVisible(True)
            self.blend_mode_combo_box.setVisible(True)
            if self.dlg.graphic_preview.scene() is not None:
                self.dlg.graphic_preview.scene().clear()
        else:
            self.dlg.combo.setVisible(True)
            self.dlg.Reverse_Top.setVisible(False)
            self.dlg.Reverse_Bottom.setVisible(False)
            self.dlg.Rotate_axis.setVisible(False)
            self.dlg.VistaPrevia.setVisible(False)
            self.blend_mode_combo_box.setVisible(False)
            self.dlg.combo.setCurrentIndex(0)
            if self.dlg.graphic_preview.scene() is not None:
                self.dlg.graphic_preview.scene().clear()
            

    def clear_view(self):
        try:
            self.path.clear()
        except AttributeError as e:
            self.path = QPainterPath()
        self.item.setPath(self.path)

    def on_click_VistaPrevia(self):
        global Vista_Previa
        Vista_Previa=True
        #error=self.Control_Errors(Vista_Previa)
        #if (error==999):
        #    return
        self.on_click_Inici()

    def on_click_Inici(self):

        global Fitxer
        global index_bottom
        global index_top
        global Camp_V1
        global Camp_V2
        global Vista_Previa
        global TOP_Layer
        global BOTTOM_Layer
        s = QSettings()
        Camp_V1=""
        Camp_V2=""
        self.dlg.coef_text.setPlainText('')
        Fitxer=datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
        consoleWidget = iface.mainWindow().findChild( QDockWidget, 'PythonConsole' )
        if consoleWidget is None:
            iface.actionShowPythonDialog().trigger()
            QApplication.processEvents()
            consoleWidget = iface.mainWindow().findChild( QDockWidget, 'PythonConsole' )
            consoleWidget.console.shellOut.clearConsole()
            consoleWidget.setVisible( False )
        
        error=self.Control_Errors(Vista_Previa)
        if (error==999):
            return
        self.dlg.progressBar.setValue(0)
        self.dlg.progressBar.setVisible(True)
        self.dlg.setEnabled(False)
        QApplication.processEvents()
        if (Vista_Previa==False):
            camp_top='V1'
            camp_bottom='V2'
            V1_top,Tipus_V1,Camp_V1=self.Calcula_index_tematic(TOP_Layer,index_top,camp_top)
            V2_bottom,Tipus_V2,Camp_V2=self.Calcula_index_tematic(BOTTOM_Layer,index_bottom,camp_bottom)
            JOIN_VAR=self.Join_variables_tematics(V1_top,V2_bottom,Tipus_V2)
            #CoefCorrel
            CoefCorrelacio=self.CalculaCoefCorrel(JOIN_VAR,Tipus_V2,Tipus_V1)
            if CoefCorrelacio!=999:
                self.dlg.coef_text.setPlainText(str(CoefCorrelacio))
            else:
                self.dlg.coef_text.setPlainText('')
                QMessageBox.information(None, "Info", "El coeficient de correlació no es pot calcular degut a que un dels temàtics està basat en regles.")
                
            layer_T3=self.Concatena_V1V2(JOIN_VAR,"comb_V1V2")
            symbol = QgsSymbol.defaultSymbol(layer_T3.geometryType())
            renderer = QgsRuleBasedRenderer(symbol)
        
        colors_TOP_Layer=self.get_colors_layer(TOP_Layer[0],False)
        colors_BOTTOM_Layer=self.get_colors_layer(BOTTOM_Layer[0],False)
        img_TOP_LAYER=self.generate_image(colors_TOP_Layer,len(colors_BOTTOM_Layer),len(colors_TOP_Layer),20,False)

        img_BOTTOM_LAYER=self.generate_image(colors_BOTTOM_Layer,len(colors_BOTTOM_Layer),len(colors_TOP_Layer),20,True)

        painter=QPainter()
        transform=QTransform()
        painter.begin(img_TOP_LAYER)
        painter.setCompositionMode(self.blend_mode)
        painter.drawImage(0,0,img_BOTTOM_LAYER)
        painter.end()
        
        if (Vista_Previa==False):
            matrix_colors=[]
            for x in range(len(colors_TOP_Layer)):
                index_y=1
                for y in reversed(range(len(colors_BOTTOM_Layer))):
                    tempColorRgb = img_TOP_LAYER.pixelColor(QPoint(20*(x+1)-10,20*(y+1)-10))
                    #print (x+1,y+1,tempColorRgb.red(),tempColorRgb.green(),tempColorRgb.blue())
                    #if self.dlg.Paleta_chk.isChecked():
                    if self.dlg.PaletaPredefinida.isChecked():
                        self.rule_based_style(layer_T3,renderer,index_top[x]+str(index_y),'"comb_V1V2"=\''+index_top[x]+str(index_y)+'\'',QColor(Paletes_RGB[self.dlg.combo.currentIndex()-1][index_y-1][x][0],Paletes_RGB[self.dlg.combo.currentIndex()-1][index_y-1][x][1],Paletes_RGB[self.dlg.combo.currentIndex()-1][index_y-1][x][2]))
                    else:
                        self.rule_based_style(layer_T3,renderer,index_top[x]+str(index_y),'"comb_V1V2"=\''+index_top[x]+str(index_y)+'\'',QColor(tempColorRgb.red(),tempColorRgb.green(),tempColorRgb.blue()))
                    #print(Paletes_RGB[self.dlg.combo.currentIndex()-1][x][index_y-1][0],Paletes_RGB[self.dlg.combo.currentIndex()-1][x][index_y-1][1],Paletes_RGB[self.dlg.combo.currentIndex()-1][x][index_y-1][2])
                    index_y=index_y+1
            renderer.rootRule().removeChildAt(0)
            layer_T3.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology(layer_T3.id())
        else:
            Vista_Previa=False

        if self.dlg.PaletaPredefinida.isChecked():
            item=QPixmap.fromImage(img_Paletes[self.dlg.combo.currentIndex()-1])
        else:
            item=QPixmap.fromImage(img_TOP_LAYER)
        scene=QGraphicsScene()
        scene.addPixmap(item)
        self.dlg.graphic_preview.setScene(scene)
        self.dlg.progressBar.setValue(0)
        self.dlg.progressBar.setVisible(False)
        self.dlg.setEnabled(True)

    def Control_Errors(self,VistaPrevia):
        global TOP_Layer
        global BOTTOM_Layer
        #############################################################################################################
        #    CONTROL D'ERRORRS
        #############################################################################################################
        if (self.dlg.Tematic_Top.currentText()=='Selecciona un temàtic'):
            QMessageBox.information(None, "Error", "S'ha de seleccionar un temàtic a la selecció de Tematic 1.")
            return 999
        else:
            TOP_Layer = QgsProject.instance().mapLayersByName(self.dlg.Tematic_Top.currentText())
            if TOP_Layer[0].renderer() is None:
                QMessageBox.information(None, "Error", "El temàtic 1 escollit no és compatible.\nNomés tematics en formats (Graduats, Categories, o per Regles)")
                return 999
            if TOP_Layer[0].renderer().type() not in ['graduatedSymbol','categorizedSymbol','RuleRenderer']:
                QMessageBox.information(None, "Error", "El temàtic 1 escollit no és compatible. Només tematics en formats (Graduats, Categories, o per Regles)")
                return 999
            if TOP_Layer[0].renderer().type()=='graduatedSymbol':
                if len(TOP_Layer[0].renderer().ranges())>max_rangs:
                    QMessageBox.information(None, "Error", "El temàtic 1 escollit conté massa rangs. El màxim de rangs admisibles és "+str(max_rangs))
                    return 999

            if TOP_Layer[0].renderer().type()=='categorizedSymbol':
                if len(TOP_Layer[0].renderer().categories())>max_rangs:
                    QMessageBox.information(None, "Error", "El temàtic 1 escollit conté massa rangs. El màxim de rangs admisibles és "+str(max_rangs))
                    return 999

            if TOP_Layer[0].renderer().type()=='RuleRenderer':
                if len(TOP_Layer[0].renderer().rootRule().children())>max_rangs:
                    QMessageBox.information(None, "Error", "El temàtic 1 escollit conté massa rangs. El màxim de rangs admisibles és "+str(max_rangs))
                    return 999


        if (self.dlg.Tematic_Bottom.currentText()=='Selecciona un temàtic'):
            QMessageBox.information(None, "Error", "S'ha de seleccionar un temàtic a la selecció de Tematic 2.")
            return 999
        else:
            BOTTOM_Layer = QgsProject.instance().mapLayersByName(self.dlg.Tematic_Bottom.currentText())
            if BOTTOM_Layer[0].renderer() is None:
                QMessageBox.information(None, "Error", "El temàtic 2 escollit no és compatible.\nNomés tematics en formats (Graduats, Categories, o per Regles)")
                return 999
            if BOTTOM_Layer[0].renderer().type() not in ['graduatedSymbol','categorizedSymbol','RuleRenderer']:
                QMessageBox.information(None, "Error", "El temàtic 2 escollit no és compatible. Només tematics en formats (Graduats, Categories, o per Regles)")
                return 999
            if BOTTOM_Layer[0].renderer().type()=='graduatedSymbol':
                if len(BOTTOM_Layer[0].renderer().ranges())>10:
                    QMessageBox.information(None, "Error", "El temàtic 2 escollit conté massa rangs. El màxim de rangs admisibles és "+str(max_rangs))
                    return 999

            if BOTTOM_Layer[0].renderer().type()=='categorizedSymbol':
                if len(BOTTOM_Layer[0].renderer().categories())>10:
                    QMessageBox.information(None, "Error", "El temàtic 2 escollit conté massa rangs. El màxim de rangs admisibles és "+str(max_rangs))
                    return 999

            if BOTTOM_Layer[0].renderer().type()=='RuleRenderer':
                if len(BOTTOM_Layer[0].renderer().rootRule().children())>10:
                    QMessageBox.information(None, "Error", "El temàtic 2 escollit conté massa rangs. El màxim de rangs admisibles és "+str(max_rangs))
                    return 999


        if (self.dlg.PaletaPredefinida.isChecked() and self.dlg.combo.currentText()=='Selecciona Paleta' and VistaPrevia==False):
            QMessageBox.information(None, "Error", "S'ha d'escollir una paleta predefinida del llistat")
            return 999
        #############################################################################################################
        #    FI CONTROL D'ERRORRS
        #############################################################################################################


    def CalculaCoefCorrel(self,Layer,Tipus_v1,Tipus_v2):
        global Camp_V1
        global Camp_V2
        if (Tipus_v1!="REGLA" and Tipus_v2!="REGLA") :
            f = QgsProcessingFeedback()
            f.progressChanged.connect(self.progress_changed)
            if (Qgis.QGIS_VERSION_INT < 30600):
                sortida='memory:'
            else:
                sortida='TEMPORARY_OUTPUT'

            #sum(  (  "RMP_2017"  -  mean("RMP_2017" ))  *   ("Index"  -  mean("Index"  ) ) )/(sqrt(  sum( ("RMP_2017" - mean("RMP_2017" ))^2)) * sqrt(sum(("Index"  -  mean("Index"))^2)))
            TEM1={
                'INPUT' : Layer,
                'FIELD_NAME' : "CoefCorr",
                'FIELD_TYPE' : 0,
                'FIELD_LENGTH' : 5,
                'FIELD_PRECISION' : 2,
                'NEW_FIELD' : True,
                'FORMULA' : 'round(sum(("'+Camp_V2+'"-mean("'+Camp_V2+'"))*("'+Camp_V1+'"-mean("'+Camp_V1+'"  ) ) )/(sqrt(  sum( ("'+Camp_V2+'" - mean("'+Camp_V2+'" ))^2)) * sqrt(sum(("'+Camp_V1+'"  -  mean("'+Camp_V1+'"))^2))),2)',
                'OUTPUT': ''+sortida+''
            }
            CORREL_LAYER=processing.run('qgis:fieldcalculator', TEM1, feedback=f)


            TEM2={
                'INPUT_LAYER' : CORREL_LAYER['OUTPUT'],
                'FIELD_NAME' : "CoefCorr",
                'MIN': ''+sortida+''
            }
            COEF_CORREL=processing.run('qgis:basicstatisticsforfields', TEM2, feedback=f)

            return COEF_CORREL['MIN']
        else:
            return 999
    
    def generate_image(self,
            colors,
            width,
            height,
            square_size,
            reverse=False):
        """
        Generate intermediate legend image for one layer.

        The input are a list of QColor, the height, the width
        and reverse for color ordering (x or y)
        """
        origin_x = 0
        origin_y = 0
        w, h = width * square_size, height * square_size
        img = QImage(w + 1, h + 1, QImage.Format_ARGB32)
        # TODO: Manage border when pen color
        # img = QImage(w + 1, h + 1, QImage.Format_ARGB32)

        qp = QPainter()
        qp.begin(img)

        for index1, val1 in enumerate(colors):
            for index in range(h):

                qp.setBrush(QColor(*val1))
                qp.setPen(Qt.NoPen)

                if reverse:
                    qp.drawRect(
                        origin_x + index1 * square_size,
                        origin_y + index * square_size,
                        origin_x + (index1 + 1) * square_size,
                        origin_y + (index + 1) * square_size
                    )
                        
                else:
                    qp.drawRect(
                        origin_x + index * square_size,
                        origin_y + index1 * square_size,
                        origin_x + (index + 1) * square_size,
                        origin_y + (index1 + 1) * square_size
                    )

        qp.end()
        
        Reverse_Top=not(self.dlg.Reverse_Top.isChecked())
        Reverse_Bottom=self.dlg.Reverse_Bottom.isChecked()

        img = img.mirrored(Reverse_Bottom,Reverse_Top)
        # Rotate if necessary
        if self.dlg.Rotate_axis.isChecked():
            trans = QTransform()
            trans.rotate(90)
            img = img.transformed(trans)
        return img 

    def get_colors_layer(self,layer, reverse):
        """Extract colors from vector layer styles."""
        colors_layer = []
        symbols_layer = layer.renderer().symbols(renderContext)
        if reverse:
            symbols_layer = reversed(symbols_layer)
        for sym in symbols_layer:
            colors_layer.append([
                sym.color().red(),
                sym.color().green(),
                sym.color().blue()
            ])
        #print(colors_layer)
        return colors_layer

    def rule_based_style(self,layer, renderer, label, expression, color):
        root_rule = renderer.rootRule()
        rule = root_rule.children()[0].clone()
        rule.setLabel(label)
        rule.setFilterExpression(expression)
        rule.symbol().setColor(color)
        root_rule.appendChild(rule)
        layer.setRenderer(renderer)

    def Calcula_index_tematic(self,Layer,index,nom_camp,):
        
        #print (Layer[0].renderer().type())
        #print (nom_camp)
        if Layer[0].renderer().type()=='graduatedSymbol':
            Tipus="GRADUAT"
            V1_expressio=''
            valor=0
            regla=Layer[0].renderer().classAttribute()
            #print(regla)
            Camp=regla

            for ran in Layer[0].renderer().ranges():
                V1_expressio=V1_expressio+'if(("'+regla+'">='+str(ran.lowerValue())+') and ("'+regla+'"<='+str(ran.upperValue())+'),\''+index[valor]+'\','
                valor=valor+1
            V1_expressio=V1_expressio+'\'no\''
            for x in range(len(Layer[0].renderer().ranges())):
                V1_expressio=V1_expressio+')'
            #print(V1_expressio)
        if Layer[0].renderer().type()=='categorizedSymbol':
            Tipus="CATEGORIA"
            V1_expressio=''
            valor=0
            regla=Layer[0].renderer().classAttribute()
            #print(regla)
            Camp=regla
            for ran in Layer[0].renderer().categories():
                V1_expressio=V1_expressio+'if(("'+regla+'"='+str(ran.value())+'),\''+index[valor]+'\','
                valor=valor+1
            V1_expressio=V1_expressio+'\'no\''
            for x in range(len(Layer[0].renderer().categories())):
                V1_expressio=V1_expressio+')'
            #print (V1_expressio)
            print

        if Layer[0].renderer().type()=='RuleRenderer':
            Tipus="REGLA"
            V1_expressio=''
            valor=0
            for fil in Layer[0].renderer().rootRule().children():
                #print(TOP_Layer[0].renderer().rootRule().children()[0].filterExpression())
                regla=fil.filterExpression()
                #print(regla)
                V1_expressio=V1_expressio+'if(('+regla+'),\''+index[valor]+'\','
                valor=valor+1
            V1_expressio=V1_expressio+'\'no\''
            for x in range(len(Layer[0].renderer().rootRule().children())):
                V1_expressio=V1_expressio+')'
            Camp="999"
            #print (V1_expressio)  
        
        sortida=self.Calcul_variable_tematic(Layer[0].id(),V1_expressio,nom_camp)      
        return sortida,Tipus,Camp

    # Processing feedback
    def progress_changed(self,progress):
        #print(progress)
        self.dlg.progressBar.setValue(progress) 
        QApplication.processEvents()

    def Join_variables_tematics(self, Layer_V1,Layer_V2,Tipus):
        global Camp_V2

        f = QgsProcessingFeedback()
        f.progressChanged.connect(self.progress_changed)
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida='memory:'
        else:
            sortida='TEMPORARY_OUTPUT'

        alg={
            'INPUT' : Layer_V2,
            'FIELD_NAME': ''+Camp_V2+'_V2',
            'FIELD_TYPE': 0,
            'NEW_FIELD': True,
            'FORMULA': ''+Camp_V2+'',
            'OUTPUT': ''+sortida+''
        }

        Layer_V2_mod=processing.run('qgis:fieldcalculator', alg, feedback=f)                
        Camp_V2=Camp_V2+'_V2'
        QgsProject.instance().addMapLayer(Layer_V2_mod['OUTPUT'])

        if Tipus!="REGLA":
            FIELDS=['V2',Camp_V2]
        else:
            FIELDS=['V2']
        #print(FIELDS)

        TEM1={
            'INPUT' : Layer_V1,
            'JOIN' : Layer_V2_mod['OUTPUT'],
            'PREDICATE': 2,
            'JOIN_FIELDS': FIELDS,
            'METHOD': 1,
            'OUTPUT': ''+sortida+''
        }
        JOIN_LAYER=processing.run('qgis:joinattributesbylocation', TEM1, feedback=f)

        #QgsProject.instance().addMapLayer(JOIN_LAYER['OUTPUT'])
        return JOIN_LAYER['OUTPUT']

    def Concatena_V1V2(self, Layer,nom_camp):
        f = QgsProcessingFeedback()
        f.progressChanged.connect(self.progress_changed)
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida='memory:'
        else:
            sortida='TEMPORARY_OUTPUT'
        #TEMATIC 1
            #'FIELD_LENGTH': 80,
        TEM1={
            'FIELD_NAME': ''+nom_camp+'',
            'FIELD_PRECISION': 0,
            'FIELD_TYPE': 2,
            'FORMULA': ' concat("V1","V2")',
            'INPUT' : Layer,
            'NEW_FIELD': True,
            'OUTPUT': ''+sortida+''
        }
        CONCAT_LAYER=processing.run('qgis:fieldcalculator', TEM1, feedback=f)
        QgsProject.instance().addMapLayer(CONCAT_LAYER['OUTPUT'])
        return CONCAT_LAYER['OUTPUT']

    def Calcul_variable_tematic(self, Layer,expressio,nom_camp):
        f = QgsProcessingFeedback()
        f.progressChanged.connect(self.progress_changed)
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida='memory:'
        else:
            sortida='TEMPORARY_OUTPUT'
        #TEMATIC 1
            #'FIELD_LENGTH': 80,
        TEM1={
            'FIELD_NAME': ''+nom_camp+'',
            'FIELD_PRECISION': 0,
            'FIELD_TYPE': 2,
            'FORMULA': ''+expressio+'',
            'INPUT' : ''+Layer+'',
            'NEW_FIELD': True,
            'OUTPUT': ''+sortida+''
        }
        ILLES_UNIQUE=processing.run('qgis:fieldcalculator', TEM1, feedback=f)
        #QgsProject.instance().addMapLayer(ILLES_UNIQUE['OUTPUT'])
        return ILLES_UNIQUE['OUTPUT']

    def Calcul_bivariable(self,Tematic1,Tematic2):
        global Detall_MEM
        f = QgsProcessingFeedback()
        f.progressChanged.connect(self.progress_changed)
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida='memory:'
        else:
            sortida='TEMPORARY_OUTPUT'
        #TEMATIC 1
        TEM1={
            'FIELD_LENGTH': 80,
            'FIELD_NAME': 'UUID',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 2,
            'FORMULA': 'uuid()',
            'INPUT' : ''+Tematic1+'',
            'NEW_FIELD': True,
            'OUTPUT': 'memory:'
        }
        ILLES_UNIQUE=processing.run('qgis:fieldcalculator', alg, feedback=f)
        #QgsProject.instance().addMapLayer(ILLES_UNIQUE['OUTPUT'])

        alg={
            'FIELD_LENGTH': 80,
            'FIELD_NAME': 'UUID',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 2,
            'FORMULA': 'uuid()',
            'INPUT' : ''+Entitat_Detall+'',
            'NEW_FIELD': True,
            #'OUTPUT': 'memory:'
            'OUTPUT': ''+sortida+''
        }
        Entitat_Detall_MEM=processing.run('qgis:fieldcalculator', alg, feedback=f)
        
        QgsProject.instance().addMapLayer(Entitat_Detall_MEM['OUTPUT'],False)
        QApplication.processEvents()

        operador=operacio_aggregate
        alg_params = {
            # Entitat Resum
            'INPUT': ILLES_UNIQUE['OUTPUT'],
            'GROUP_BY': 'UUID',
            'AGGREGATES' : [{'aggregate': 'first_value',
                             'delimiter': ';', 
                             'input': 'UUID', 
                             'length': 80, 
                             'name': 'UUID', 
                             'precision': 0, 
                             'type': 10
                            },
                            {'aggregate': 'first_value',
                             'delimiter': ';', 
                             #'input': 'aggregate(layer:=\''+Entitat_Detall+'\', aggregate:=\''+operador+'\',expression:="'+camp+'", filter:='+operacion+'( $geometry , geometry( @parent)),concatenator:=\'-\')', 
                             'input': 'aggregate(layer:=\''+Detall_MEM+'\', aggregate:=\''+operador+'\',expression:="'+camp+'", filter:='+operacion+'( $geometry , geometry( @parent)),concatenator:=\'-\')', 
                             'length': -1, 
                             'name': Camp_out, 
                             'precision': -1, 
                             'type': tipus
                            }],
            'OUTPUT': ''+sortida+''
        }

        #print (alg_params)
        pep=processing.run('qgis:aggregate', alg_params, feedback=f)
        #QgsProject.instance().addMapLayer(pep['OUTPUT'])
        QgsProject.instance().removeMapLayer(Detall_MEM)
        
        #'output_84afc2ff_07a0_4771_9dd7_570fcd85e1dc',
        alg={
            'INPUT' : ILLES_UNIQUE['OUTPUT'],
            'FIELD' : 'UUID',
            'INPUT_2' : pep['OUTPUT'],
            'FIELD_2' : 'UUID',
            'FIELDS_TO_COPY' : [Camp_out],
            'METHOD' : 1,
            'DISCARD_NONMATCHING' : False,
            'PREFIX' : '',
            'OUTPUT': ''+sortida+''
            }
        #print(alg)
        pep2 = processing.run('native:joinattributestable', alg, feedback=f)
        #QgsProject.instance().addMapLayer(pep2['OUTPUT'])
        
        #QgsProject.instance().addMapLayer(pep['OUTPUT'])      
        alg = {
            'INPUT': pep2['OUTPUT'],
            'COLUMN': 'UUID',
            'OUTPUT': ''+sortida+''
        }
        
        pep3 = processing.run('qgis:deletecolumn', alg, feedback=f)
        pep3['OUTPUT'].setName('Agregacio')
        return pep3['OUTPUT']
    def on_Change_ComboTOP(self):
        if (self.dlg.Tematic_Top.currentText()!='Selecciona un temàtic'):
            Top_Layer = QgsProject.instance().mapLayersByName(self.dlg.Tematic_Top.currentText())
            #self.Omple_Camps(self.dlg.Camps_list,Resum_Layer[0])
            #filtro='tot'
            #self.Omple_Camps(self.dlg.atr_Resum,Top_Layer[0],filtro)
        #else:
            #self.dlg.atr_Resum.clear()

    def on_Change_ComboBOTTOM(self):
        if (self.dlg.Tematic_Top.currentText()!='Selecciona un temàtic'):
            Top_Layer = QgsProject.instance().mapLayersByName(self.dlg.Tematic_Bottom.currentText())

    def Recarga_Llegenda_TOP(self):
        self.cerca_elements_Leyenda(self.dlg.Tematic_Top,'all')    

    def on_Change_combo_Paleta(self):
        global img_Paletes
        if (self.dlg.combo.currentText()!='Selecciona Paleta'):
            item=QPixmap.fromImage(img_Paletes[self.dlg.combo.currentIndex()-1])
            scene=QGraphicsScene()
            scene.addPixmap(item)
            self.dlg.graphic_preview.setScene(scene)

        
    def Recarga_Llegenda_BOTTOM(self):
        self.cerca_elements_Leyenda(self.dlg.Tematic_Bottom,'all')    

    def cerca_elements_Leyenda(self,combo,tipus): #tipus ha de ser QgsWkbTypes.Point or el que sigui
        
        if combo != 'Selecciona connexió':
            try: #Accedir als elements de la llegenda que siguin de tipus punt.
                aux = []
                layers = QgsProject.instance().mapLayers().values()
                for layer in layers:
                    #print(layer.type())
                    if layer.type()==QgsMapLayer.VectorLayer:
                        if tipus=='all' :
                            aux.append(layer.name())
                        elif layer.wkbType() in tipus:
                            aux.append(layer.name())

                        
                self.ompleCombos(combo, aux, 'Selecciona un temàtic', True)
            except Exception as ex:
                missatge="Error al afegir els elements de la llegenda"
                print (missatge)
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", missatge)
                return

    def ompleCombos(self, combo, llista, predef, sort):
        """Aquesta funci� omple els combos que li passem per par�metres"""
        combo.blockSignals (True)
        combo.clear()
        model=QStandardItemModel(combo)
        predefInList = None
        for elem in llista:
            try:
                if isinstance(elem, tuple):
                    item = QStandardItem(unicode(elem[0]))
                else:
                    item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem[0]))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0,predef)
                combo.setCurrentIndex(0)
        combo.blockSignals (False)

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Tematic_Bivariable/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Creador de tematics bivariables'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&CCU'),
                action)
            self.toolbar.removeAction(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
        self.EstatInicial()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
